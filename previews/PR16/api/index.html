<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Newton.jl</title><meta name="title" content="API · Newton.jl"/><meta property="og:title" content="API · Newton.jl"/><meta property="twitter:title" content="API · Newton.jl"/><meta name="description" content="Documentation for Newton.jl."/><meta property="og:description" content="Documentation for Newton.jl."/><meta property="twitter:description" content="Documentation for Newton.jl."/><meta property="og:url" content="https://KnutAM.github.io/Newton.jl/api/"/><meta property="twitter:url" content="https://KnutAM.github.io/Newton.jl/api/"/><link rel="canonical" href="https://KnutAM.github.io/Newton.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Newton.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#API"><span>API</span></a></li><li><a class="tocitem" href="#Internal-API"><span>Internal API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/KnutAM/Newton.jl/blob/main/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><h3 id="Standard-usage"><a class="docs-heading-anchor" href="#Standard-usage">Standard usage</a><a id="Standard-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-usage" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.newtonsolve" href="#Newton.newtonsolve"><code>Newton.newtonsolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newtonsolve(rf!, x0::AbstractVector, [cache::NewtonCache]; tol=1.e-6, maxiter=100)</code></pre><p>Solve the nonlinear equation (system) <code>r(x)=0</code> using the newton-raphson method by calling the mutating residual function <code>rf!(r, x)</code>, with signature <code>rf!(r::T, x::T)::T where T&lt;:AbstractVector</code> <code>x0</code> is the initial guess and the optional <code>cache</code> can be preallocated by calling <code>NewtonCache(x0)</code>. Note that <code>x0</code> is not modified, unless aliased to <code>getx(cache)</code>.  <code>tol</code> is the tolerance for <code>norm(r)</code> and <code>maxiter</code> the maximum number of iterations. </p><p>returns <code>x, drdx, converged::Bool</code></p><p><code>drdx</code> is the derivative of r wrt. x at the returned <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/newtonsolve.jl#L1-L13">source</a></section><section><div><pre><code class="language-julia hljs">newtonsolve(rf, x0::T; tol=1.e-6, maxiter=100, [linsolver]) where {T &lt;: 
    Union{Number, StaticArrays.SVector, Tensors.Vec, Tensors.SecondOrderTensor}}</code></pre><p>Solve the nonlinear equation (system) <code>r(x)=0</code> using the newton-raphson method by calling the residual function <code>r=rf(x)</code>, with signature <code>rf(x::T)::T</code> <code>x0::T</code> is the initial guess, <code>tol</code> the tolerance form <code>norm(r)</code>, and <code>maxiter</code> the maximum number  of iterations.</p><p>A non-standard <code>linsolver</code> can optionally be specified, please see <a href="#Newton.AbstractLinsolver">Linear solvers</a> for more information.</p><p>returns: <code>x, drdx, converged::Bool</code></p><p><code>drdx</code> is the derivative of r wrt. x at the returned <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/newtonsolve.jl#L48-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.NewtonCache" href="#Newton.NewtonCache"><code>Newton.NewtonCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function NewtonCache(x::AbstractVector; [linsolver])</code></pre><p>Create the cache used by the <code>newtonsolve</code> and <code>linsolve!</code>.  Only a copy of <code>x</code> will be used.</p><p>A special <code>linsolver</code> can optionally be given, please see <a href="#Newton.AbstractLinsolver">Linear solvers</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/NewtonCache.jl#L10-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.getx" href="#Newton.getx"><code>Newton.getx</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getx(cache::NewtonCache)</code></pre><p>Extract out the unknown values. This can be used to avoid  allocations when solving defining the initial guess. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/NewtonCache.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.logging_mode" href="#Newton.logging_mode"><code>Newton.logging_mode</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Newton.logging_mode(; enable=true)</code></pre><p>Helper to turn on (<code>enable=true</code>) or off (<code>enable=false</code>) logging of iterations in <code>Newton.jl</code>. Internally, changes the how <code>Newton.@if_logging expr</code> is evaluated:  when logging mode is enabled, <code>expr</code> is evaluated, otherwise <code>expr</code> is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/utils.jl#L6-L11">source</a></section></article><h3 id="Available-linear-solvers"><a class="docs-heading-anchor" href="#Available-linear-solvers">Available linear solvers</a><a id="Available-linear-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Available-linear-solvers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.AbstractLinsolver" href="#Newton.AbstractLinsolver"><code>Newton.AbstractLinsolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Newton.jl comes with the following linear solvers</p><ul><li><a href="#Newton.StandardLinsolver">StandardLinsolver</a> (default)</li><li><a href="#Newton.UnsafeFastLinsolver">UnsafeFastLinsolver</a></li><li><a href="#Newton.RecursiveFactorizationLinsolver">RecursiveFactorizationLinsolver</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/linsolve.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.StandardLinsolver" href="#Newton.StandardLinsolver"><code>Newton.StandardLinsolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Newton.StandardLinsolver()</code></pre><p>This is the default linear solver, which gives safe operations and don&#39;t require any special packages to be loaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/linsolve.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.UnsafeFastLinsolver" href="#Newton.UnsafeFastLinsolver"><code>Newton.UnsafeFastLinsolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnsafeFastLinsolver()</code></pre><p>This is a special linear solver, which calculates the inverse recursively by using the analytical inverses of 2x2 and 3x3 matrices. This gives exceptional performance for small matrices, but suffers from numerical errors and can be sensitive to  badly conditioned matrices. When using this method, it may be advisable to (adaptively) try a slower method if the newton  iterations fail to converge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/linsolve.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.RecursiveFactorizationLinsolver" href="#Newton.RecursiveFactorizationLinsolver"><code>Newton.RecursiveFactorizationLinsolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RecursiveFactorizationLinsolver()</code></pre><p>This linear solver utilizes the LU decomposition in <code>RecursiveFactorization.jl</code>, which gives faster performance than the  <code>StandardLinsolver</code>. While not as fast as <code>UnsafeFastLinsolver</code>, it is always accurate. Is available via an extension,  requiring the user to load <code>RecursiveFactorization.jl</code> separately. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/linsolve.jl#L31-L37">source</a></section></article><h3 id="Fast-inverse"><a class="docs-heading-anchor" href="#Fast-inverse">Fast inverse</a><a id="Fast-inverse-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-inverse" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.inv!" href="#Newton.inv!"><code>Newton.inv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Newton.inv!(A::Matrix, cache::NewtonCache)</code></pre><p>In-place inverse, which, depending on the <code>linsolver</code> in <code>cache</code>, can be much more  efficient than <code>inv(A)</code>. However, note that <code>A</code> will be used as workspace and values should not be used after calling <code>Newton.inv!</code>. In some cases,  <code>A</code> will become its inverse, and the output aliased to <code>A</code>.  This behavior is not true in general, and should not be relied upon. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/inverse.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.sinv" href="#Newton.sinv"><code>Newton.sinv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sinv(a::SMatrix{d, d}) where {d}</code></pre><p>Fast, but numerically unstable implementation of the inverse of a statically sized matrix. Beneficial up to d ≈ 50, but can give large floating point errors for badly conditioned and/or large matrices.</p><p>About 4 to 5 timers faster than StaticArrays for sizes ∈ [5, 20], and at least twice as fast up to 50 according  to benchmarks on macbook with M3 processor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/inverse.jl#L79-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.sinv!" href="#Newton.sinv!"><code>Newton.sinv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sinv!(K::Matrix)</code></pre><p>Invert <code>K</code> in-place using the unsafe static implementation up to a size of 20x20, and fall back to generic <code>LinearAlgebra.inv</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/inverse.jl#L168-L173">source</a></section></article><h3 id="Use-inside-AD-calls"><a class="docs-heading-anchor" href="#Use-inside-AD-calls">Use inside AD-calls</a><a id="Use-inside-AD-calls-1"></a><a class="docs-heading-anchor-permalink" href="#Use-inside-AD-calls" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.ad_newtonsolve" href="#Newton.ad_newtonsolve"><code>Newton.ad_newtonsolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ad_newtonsolve(rf, x0, rf_dual_args::Tuple; kwargs...)</code></pre><p>Solve <code>rf(x, y₁(z), y₂(z), ...) = 0</code> to find <code>x(y₁(z), y₂(z), ...)</code>, given the initial guess <code>x0</code> as a non-dual number, and the dual input numbers  <code>rf_dual_args = (y₁(z), y₂(z), ...)</code> where all are derivatives wrt. the same variable <code>z</code>. Return <code>x</code> of <code>Dual</code> type seeded such that it corresponds to the derivative <code>dx/dz = ∂x/∂yᵢ ⋆ dyᵢ/dz</code> where <code>⋆</code> is the appropriate contraction.</p><p><strong>Implementation:</strong> </p><p>Uses the adjoint, i.e. <code>dr/dyᵢ = 0 = ∂r/∂x ⋆ ∂x/∂yᵢ + ∂r/∂yᵢ ⇒ ∂x/∂yᵢ = -[∂r/∂x]⁻¹ ⋆ ∂r/∂yᵢ</code>,  such that we avoid doing newton iterations with dual numbers. </p><pre><code class="nohighlight hljs">ad_newtonsolve(rf, x0, rf_args::Tuple; kwargs...)</code></pre><p>If <code>rf_args</code> do not contain dual numbers, the standard newtonsolver is just called on  <code>f(x) = rf(x, y₁, y₂, ...)</code>, and the solution <code>x</code> is returned. This allows writing generic  code where the gradient is sometimes required, but not always. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Newton, Tensors, ForwardDiff, BenchmarkTools
rf(x::Vec, a::Number) = a * x - (x ⋅ x) * x
function myfun!(outputs::Vector, inputs::Vector)
    x0 = ones(Vec{2}) # Initial guess
    a = inputs[1] + 2 * inputs[2]
    x, converged = ad_newtonsolve(rf, x0, (a,))
    outputs[1] = x ⋅ x
    outputs[2] = a * x[1]
    return outputs 
end
out = zeros(2); inp = [1.2, 0.5]
ForwardDiff.jacobian(myfun!, out, inp)</code></pre><p>gives</p><pre><code class="nohighlight hljs">2×2 Matrix{Float64}:
 1.0      2.0
 1.57321  3.14643</code></pre><div class="admonition is-info" id="Note-8e6d950fbd8aee1e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8e6d950fbd8aee1e" title="Permalink"></a></header><div class="admonition-body"><p>The maximum length of <code>rf_dual_args</code> where it is highly efficient is currently 5. For longer length there will be a dynamic dispatch, but this number can be extended  by adding more methods to the <em>internal</em> <code>Newton.get_dual_results</code> function.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/ad_solve.jl#L4-L51">source</a></section></article><p>This approach is faster then naively differentiating a call which includes a newtonsolve, as we avoid iterating using <code>Dual</code> numbers. </p><pre><code class="language-julia hljs">using Newton, Tensors, ForwardDiff, BenchmarkTools
rf(x::Vec, a::Number) = a * x - (x ⋅ x) * x
function myfun!(outputs::Vector, inputs::Vector)
    x0 = ones(Vec{2}) # Initial guess
    a = inputs[1] + 2 * inputs[2]
    x, converged = ad_newtonsolve(rf, x0, (a,))
    outputs[1] = x ⋅ x
    outputs[2] = a * x[1]
    return outputs 
end
function myfun2!(outputs::Vector, inputs::Vector)
    x0 = ones(Vec{2}) # Initial guess
    a = inputs[1] + 2 * inputs[2]
    x, _, converged = newtonsolve(x -&gt; rf(x, a), x0)
    outputs[1] = x ⋅ x
    outputs[2] = a * x[1]
    return outputs
end
J = zeros(2,2)
out = zeros(2); inp = [1.2, 0.5]
cfg = ForwardDiff.JacobianConfig(myfun!, out, inp)
cfg2 = ForwardDiff.JacobianConfig(myfun2!, out, inp)
# Call the standard function using newtonsolve
@btime myfun2!($out, $inp);                                     # 143.381 ns (0 allocations: 0 bytes)
# Differentiate through newtonsolve
@btime ForwardDiff.jacobian!($J, $myfun2!, $out, $inp, $cfg2);  # 285.662 ns (0 allocations: 0 bytes)
# Call the function which uses ad_newtonsolve (no difference)
@btime myfun!($out, $inp);                                      # 143.381 ns (0 allocations: 0 bytes)
# Differentiate through ad_newtonsolve
@btime ForwardDiff.jacobian!($J, $myfun!, $out, $inp, $cfg);    # 183.359 ns (0 allocations: 0 bytes)</code></pre><p>showing that we get quite close to a regular non-differentiating call wrt. computational time in this microbenchmark.</p><h2 id="Internal-API"><a class="docs-heading-anchor" href="#Internal-API">Internal API</a><a id="Internal-API-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.linsolve!" href="#Newton.linsolve!"><code>Newton.linsolve!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linsolve!(K::AbstractMatrix, b::AbstractVector, cache::NewtonCache)</code></pre><p>Solves the linear equation system <code>Kx=b</code>, mutating both <code>K</code> and <code>b</code>. <code>b</code> is mutated to the solution <code>x</code>.</p><pre><code class="nohighlight hljs">linsolve!(linsolver, K::AbstractMatrix, b::AbstractVector, cache::NewtonCache)</code></pre><p>The default implementation will call this signature, which should be overloaded for a different  <code>linsolver</code> passed to <code>cache</code> upon construction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/linsolve.jl#L48-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.linsolve" href="#Newton.linsolve"><code>Newton.linsolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linsolve(linsolver, K, b)</code></pre><p>Solve the equation (system) <code>b = K ⋆ x</code> where <code>⋆</code> is the appropriate contraction between <code>K</code> and <code>x</code>, and <code>b</code> and <code>x</code> have the same type and size. The following combinations of <code>K</code> and <code>x</code> are supported. </p><table><tr><th style="text-align: right">K</th><th style="text-align: right"><code>b</code>, <code>x</code></th></tr><tr><td style="text-align: right"><code>Number</code></td><td style="text-align: right"><code>Number</code></td></tr><tr><td style="text-align: right"><code>SMatrix{N, N}</code></td><td style="text-align: right"><code>SVector{N}</code></td></tr><tr><td style="text-align: right"><code>SecondOrderTensor{d}</code></td><td style="text-align: right"><code>AbstractTensor{o, d}</code></td></tr><tr><td style="text-align: right"><code>FourthOrderTensor{d}</code></td><td style="text-align: right"><code>AbstractTensor{o, d}</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/linsolve.jl#L79-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.extract_submatrix" href="#Newton.extract_submatrix"><code>Newton.extract_submatrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_submatrix(::Type{SMatrix{d1, d2}}, m::SMatrix, start_row, start_col)</code></pre><p>Efficiently extract <code>s::SMatrix{d1, d2}</code> such that  <code>s == m[start_row:(start_row + d1 - 1), start_col:(start_col + d2 - 1)]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/inverse.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Newton.join_submatrices" href="#Newton.join_submatrices"><code>Newton.join_submatrices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">join_submatrices(a11, a12, a21, a22)</code></pre><p>Efficiently join the submatrices to return a::SMatrix = [a11 a12; a21 a22].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KnutAM/Newton.jl/blob/0abadbec492919bcd941c8dc0440d9c50224eb8e/src/inverse.jl#L119-L123">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 5 August 2025 20:35">Tuesday 5 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
