var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Newton","category":"page"},{"location":"#Newton","page":"Home","title":"Newton","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of the small Newton.jl package is to provide a fast and efficient newton-raphson solver for nonlinear equation systems, suitable to be used inside a preformance critical loop. It is mostly tested for small equations systems (<100 variables). When more fine-grained controlled over algorithms or more iteration information is desired, using NLsolve is recommended.","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"#Mutating-standard-array","page":"Home","title":"Mutating standard array","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Newton","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define a mutating residual function rf!","category":"page"},{"location":"","page":"Home","title":"Home","text":"nsize=4\n(a,b) = [rand(nsize) for _ in 1:2]\nfunction rf!(r, x)\n    r .= - a + b.*x + exp.(x)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define initial guess x","category":"page"},{"location":"","page":"Home","title":"Home","text":"x=zeros(nsize)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Preallocate cache ","category":"page"},{"location":"","page":"Home","title":"Home","text":"cache = NewtonCache(x,rf!)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solve the problem r=0","category":"page"},{"location":"","page":"Home","title":"Home","text":"drdx = get_drdx(cache)  # Alternatively drdx=zeros(nsize,nsize), but this allocates \nconverged = newtonsolve!(x, drdx, rf!, cache)","category":"page"},{"location":"#Speed-and-allocation-comparison","page":"Home","title":"Speed and allocation comparison","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See benchmarks/benchmark.jl, on my laptop the results are","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"benchmarks/benchmark.jl\")\n@btime rf!\n  200.000 ns (0 allocations: 0 bytes)\n@btime newtonsolve!\n  29.400 μs (7 allocations: 6.12 KiB)\n@btime nlsolve\n  51.500 μs (74 allocations: 40.98 KiB)\nBenchmark (dim=20) complete","category":"page"},{"location":"","page":"Home","title":"Home","text":"showing that newtonsolve! is approximately 1.75 times faster than the basic usage of nlsolve for this particular case.","category":"page"},{"location":"#Using-StaticArrays","page":"Home","title":"Using StaticArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Newton","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define a non-mutating residual function","category":"page"},{"location":"","page":"Home","title":"Home","text":"function rf(x::SVector)\n    return exp.(x) - x.^2\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Provide an initial guess","category":"page"},{"location":"","page":"Home","title":"Home","text":"x_s = zero(SVector{dim})","category":"page"},{"location":"","page":"Home","title":"Home","text":"Find the x that solves the non-linear equation system r(x)=0, as well as the jacobian drdx at that x,","category":"page"},{"location":"","page":"Home","title":"Home","text":"converged, x, drdx = newtonsolve($x_s, $rf);","category":"page"},{"location":"#Speed-comparison","page":"Home","title":"Speed comparison","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See benchmarks/benchmark_static.jl, on my laptop the results are","category":"page"},{"location":"","page":"Home","title":"Home","text":"include(\"benchmarks/benchmark_static.jl\")\nBenchmark with dim=5\nrf (static):           27.163 ns (0 allocations: 0 bytes)\nrf (dynamic):          30.050 ns (0 allocations: 0 bytes)\nnewtonsolve static:    958.333 ns (0 allocations: 0 bytes)\nnewtonsolve dynamic:   2.600 μs (9 allocations: 1.22 KiB)\nnlsolve dynamic:       6.600 μs (58 allocations: 6.23 KiB)\n\nBenchmark with dim=10\nrf (static):           56.504 ns (0 allocations: 0 bytes)\nrf (dynamic):          55.793 ns (0 allocations: 0 bytes)\nnewtonsolve static:    4.037 μs (0 allocations: 0 bytes)\nnewtonsolve dynamic:   5.400 μs (5 allocations: 4.38 KiB)\nnlsolve dynamic:       10.400 μs (58 allocations: 12.25 KiB)\n\nBenchmark with dim=20\nrf (static):           105.443 ns (0 allocations: 0 bytes)\nrf (dynamic):          109.257 ns (0 allocations: 0 bytes)\nnewtonsolve static:    8.433 μs (16 allocations: 14.81 KiB)\nnewtonsolve dynamic:   14.800 μs (5 allocations: 4.38 KiB)\nnlsolve dynamic:       25.800 μs (62 allocations: 23.39 KiB)","category":"page"},{"location":"","page":"Home","title":"Home","text":"showing that using StaticArrays will be significantly faster with newtonsolve. (nlsolve does not  support StaticArrays.)","category":"page"},{"location":"#Exported-API","page":"Home","title":"Exported API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Newton]\nPrivate = false","category":"page"},{"location":"#Newton.NewtonCache-Tuple{AbstractVector, Any}","page":"Home","title":"Newton.NewtonCache","text":"function NewtonCache(x::AbstractVector, rf!)\n\nCreate the cache used by the newtonsolve! and linsolve!  to find x such that rf!(r,x) yields r=0.\n\n\n\n\n\n","category":"method"},{"location":"#Newton.get_drdx-Tuple{NewtonCache}","page":"Home","title":"Newton.get_drdx","text":"get_drdx(cache::NewtonCache) = DiffResults.jacobian(cache.result)\n\n\n\n\n\n","category":"method"},{"location":"#Newton.newtonsolve!","page":"Home","title":"Newton.newtonsolve!","text":"newtonsolve!(x::AbstractVector, drdx::AbstractMatrix, rf!, cache::ResidualCache; tol=1.e-6, maxiter=100)\n\nSolve the nonlinear equation system r(x)=0 using the newton-raphson method. Returns true if converged and false otherwise.\n\nargs\n\nx: Vector of unknowns. Provide as initial guess, mutated to solution.\ndrdx: Jacobian matrix. Only provided as preallocation. Can be aliased to DiffResults.jacobian(cache.result)\nrf!: Residual function. Signature rf!(r, x) and mutating the residual r\ncache: Optional cache that can be preallocated by calling ResidualCache(x, rf!)\n\nkwargs\n\ntol=1.e-6: Tolerance on norm(r)\nmaxiter=100: Maximum number of iterations before no convergence\n\n\n\n\n\n","category":"function"},{"location":"#Newton.newtonsolve-Union{Tuple{dim}, Tuple{StaticArrays.SVector{dim}, Any}} where dim","page":"Home","title":"Newton.newtonsolve","text":"newtonsolve(x::SVector, rf; tol=1.e-6, max_iter=100)\n\nSolve the nonlinear equation system r(x)=0 using the newton-raphson method. Returns type: (converged, x, drdx), SVector, SMatrix)` where \n\nconverged::Bool is trueif converged andfalse` otherwise\nx::SVector is the solution vector such that r(x)=0\ndrdx::SMatrix is the jacobian at x\n\nargs\n\nx: Vector of unknowns. Provide as initial guess, mutated to solution.\nrf: Residual function. Signature r=rf(x::SVector{dim})::SVector{dim}\n\nkwargs\n\ntol=1.e-6: Tolerance on norm(r)\nmaxiter=100: Maximum number of iterations before no convergence\n\n\n\n\n\n","category":"method"},{"location":"#Internal-API","page":"Home","title":"Internal API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Newton]\nPublic = false","category":"page"},{"location":"#Newton.linsolve!-Tuple{AbstractMatrix, AbstractVector, NewtonCache}","page":"Home","title":"Newton.linsolve!","text":"linsolve!(K::AbstractMatrix, b::AbstractVector, cache::NewtonCache)\n\nSolves the linear equation system Kx=b, mutating both K and b. b is mutated to the solution x\n\n\n\n\n\n","category":"method"},{"location":"#Newton.linsolve-Union{Tuple{dim}, Tuple{StaticArrays.SMatrix{dim, dim}, StaticArrays.SVector{dim}}} where dim","page":"Home","title":"Newton.linsolve","text":"linsolve(drdx::SMatrix{dim,dim}, r::SVector{dim}) where{dim}\n\nSolves the linear equation system drdx*x=r without mutating and returns the solution x\n\n\n\n\n\n","category":"method"}]
}
