var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Newton","category":"page"},{"location":"#Newton","page":"Home","title":"Newton","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of the small Newton.jl package is to provide a fast and efficient newton-raphson solver for nonlinear equation systems, suitable to be used inside a preformance critical loop. A key feature is that the jacobian at the solution is returned. It is mostly tested for small equations systems (<100 variables). When more fine-grained controlled over algorithms or more iteration information is desired, using NLsolve is recommended.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Mutating-standard-array","page":"Home","title":"Mutating standard array","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Newton","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define a mutating residual function rf!","category":"page"},{"location":"","page":"Home","title":"Home","text":"function rf!(r::Vector, x::Vector)\n    return map!(v->(exp(v)-v^2), r, x)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define the unknown array x and preallocate cache cache","category":"page"},{"location":"","page":"Home","title":"Home","text":"x=zeros(5)\ncache = NewtonCache(x,rf!)","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the place where we want to solve the problem r=0","category":"page"},{"location":"","page":"Home","title":"Home","text":"x0 = getx(cache)\n# Modify x0 as you wish to provide initial guess\nx, drdx, converged = newtonsolve!(x0, rf!, cache)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is not necessary to get x0 from the cache, but this avoids any allocations. This implies that x0 will be aliased to the output, i.e. x0===x after solving. ","category":"page"},{"location":"#Using-StaticArrays","page":"Home","title":"Using StaticArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using static arrays, the residual function should be non-mutating, i.e. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"function rf(x::SVector)\n    return exp.(x) - x.^2\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"No cache setup is required for static arrays. Hence, define an initial guess x0 and call the newtonsolve","category":"page"},{"location":"","page":"Home","title":"Home","text":"x0 = zero(SVector{dim})\nx, drdx, converged = newtonsolve(x0, rf);","category":"page"},{"location":"","page":"Home","title":"Home","text":"which as in the mutatable array case returns a the solution vector, the jacobian at the solution and a boolean whether  the solver converged or not. ","category":"page"},{"location":"#Speed-comparison","page":"Home","title":"Speed comparison","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See benchmarks/benchmark.jl, on my laptop the results are","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> activate benchmarks/\njulia> include(\"benchmarks/benchmarks.jl\");\nBenchmark with dim=5\nrf (static):           33.099 ns (0 allocations: 0 bytes)\nrf (dynamic):          32.931 ns (0 allocations: 0 bytes)\nnewtonsolve static:    1.000 μs (0 allocations: 0 bytes)\nnewtonsolve dynamic:   2.400 μs (11 allocations: 1.50 KiB)\nnlsolve dynamic:       6.900 μs (58 allocations: 6.23 KiB)\n\nBenchmark with dim=10\nrf (static):           61.491 ns (0 allocations: 0 bytes)\nrf (dynamic):          66.187 ns (0 allocations: 0 bytes)\nnewtonsolve static:    4.200 μs (0 allocations: 0 bytes)\nnewtonsolve dynamic:   5.100 μs (7 allocations: 5.28 KiB)\nnlsolve dynamic:       11.400 μs (58 allocations: 12.25 KiB)\n\nBenchmark with dim=20\nrf (static):           119.333 ns (0 allocations: 0 bytes)\nrf (dynamic):          125.471 ns (0 allocations: 0 bytes)\nnewtonsolve static:    7.900 μs (16 allocations: 14.81 KiB)\nnewtonsolve dynamic:   14.600 μs (5 allocations: 4.38 KiB)\nnlsolve dynamic:       29.100 μs (62 allocations: 23.39 KiB)\n\nBenchmark with dim=40\nrf (static):           265.634 ns (0 allocations: 0 bytes)\nrf (dynamic):          251.370 ns (0 allocations: 0 bytes)\nnewtonsolve static:    38.600 μs (16 allocations: 53.69 KiB)\nnewtonsolve dynamic:   53.200 μs (5 allocations: 4.38 KiB)\nnlsolve dynamic:       83.400 μs (67 allocations: 55.67 KiB)","category":"page"},{"location":"","page":"Home","title":"Home","text":"showing that static arrays are faster than dynamic arrays with newtonsolve and that newtonsolve outperforms nlsolve in these specific cases. (nlsolve does not  support StaticArrays.)","category":"page"},{"location":"#Exported-API","page":"Home","title":"Exported API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Newton]\nPrivate = false","category":"page"},{"location":"#Newton.NewtonCache-Tuple{AbstractVector, Any}","page":"Home","title":"Newton.NewtonCache","text":"function NewtonCache(x::AbstractVector, rf!)\n\nCreate the cache used by the newtonsolve and linsolve!.  Only a copy of x will be used. \n\n\n\n\n\n","category":"method"},{"location":"#Newton.getx-Tuple{NewtonCache}","page":"Home","title":"Newton.getx","text":"getx(cache::NewtonCache)\n\nExtract out the unknown values. This can be used to avoid  allocations when solving defining the initial guess. \n\n\n\n\n\n","category":"method"},{"location":"#Newton.newtonsolve","page":"Home","title":"Newton.newtonsolve","text":"newtonsolve!(x::AbstractVector, drdx::AbstractMatrix, rf!, cache::ResidualCache; tol=1.e-6, maxiter=100)\n\nSolve the nonlinear equation system r(x)=0 using the newton-raphson method.  Returns x, drdx, true if converged and x, drdx, false otherwise.\n\nargs\n\nx0: Initial guess. (If aliased to getx(cache) it will be mutated.)\nrf!: Residual function. Signature rf!(r, x) and mutating the residual r\ncache: Optional cache that can be preallocated by calling ResidualCache(x0, rf!)\n\nkwargs\n\ntol=1.e-6: Tolerance on norm(r)\nmaxiter=100: Maximum number of iterations before no convergence\n\n\n\n\n\n","category":"function"},{"location":"#Newton.newtonsolve-Union{Tuple{dim}, Tuple{StaticArrays.SVector{dim}, Any}} where dim","page":"Home","title":"Newton.newtonsolve","text":"newtonsolve(x0::SVector, rf; tol=1.e-6, maxiter=100)\n\nSolve the nonlinear equation system r(x)=0 using the newton-raphson method. Returns type: (converged, x, drdx), SVector, SMatrix)` where \n\nconverged::Bool is true if converged and false otherwise\nx::SVector is the solution vector such that r(x)=0\ndrdx::SMatrix is the jacobian at x\n\nargs\n\nx0: Vector of with initial guess for unknowns.\nrf: Residual function. Signature r=rf(x::SVector{dim})::SVector{dim}\n\nkwargs\n\ntol=1.e-6: Tolerance on norm(r)\nmaxiter=100: Maximum number of iterations before no convergence\n\n\n\n\n\n","category":"method"},{"location":"#Internal-API","page":"Home","title":"Internal API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Newton]\nPublic = false","category":"page"},{"location":"#Newton.linsolve!-Tuple{AbstractMatrix, AbstractVector, NewtonCache}","page":"Home","title":"Newton.linsolve!","text":"linsolve!(K::AbstractMatrix, b::AbstractVector, cache::NewtonCache)\n\nSolves the linear equation system Kx=b, mutating both K and b. b is mutated to the solution x\n\n\n\n\n\n","category":"method"}]
}
