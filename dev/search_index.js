var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Newton","category":"page"},{"location":"#Newton","page":"Home","title":"Newton","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of the small Newton.jl package is to provide a fast and efficient newton-raphson solver for nonlinear equation systems, suitable to be used inside a preformance critical loop. A key feature is that the jacobian at the solution is returned. It is mostly tested for small equations systems (<100 variables). When more fine-grained controlled over algorithms or more iteration information is desired, using NLsolve is recommended.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/KnutAM/Newton.jl\")\nusing Newton","category":"page"},{"location":"#Typical-usage","page":"Home","title":"Typical usage","text":"","category":"section"},{"location":"#Mutating-(standard)-Array","page":"Home","title":"Mutating (standard) Array","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Initial setup (before running simulation):  Define a mutating residual function rf! which depends on  parameters, e.g. a and b, only available during the simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"function rf!(r::Vector, x::Vector, a, b)\n    return map!(v->(exp(a*v)-b*v^2), r, x)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define the unknown array x and a residual function with the signature rf!(r,x) with inputs a and b of the same type as will be used later. Then preallocate cache","category":"page"},{"location":"","page":"Home","title":"Home","text":"x=zeros(5)\na = 1.0; b=1.0\nmock_rf!(r_, x_) = rf!(r_, x_, a, b)\ncache = NewtonCache(x,mock_rf!)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Runtime setup (inside simulation): At the place where we want to solve the problem r(x)=0","category":"page"},{"location":"","page":"Home","title":"Home","text":"a, b = rand(2); # However they are calculated during simulations\ntrue_rf!(r_, x_) = rf!(r_, x_, a, b)\nx0 = getx(cache)\n# Modify x0 as you wish to provide initial guess\nx, drdx, converged = newtonsolve(x0, true_rf!, cache)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is not necessary to get x0 from the cache, but this avoids allocating it. However, this implies that x0 will be aliased to the output, i.e. x0===x after solving. ","category":"page"},{"location":"#Non-mutating-StaticArray","page":"Home","title":"Non-mutating StaticArray","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Initial setup (before running simulation):  When using static arrays, the residual function should be non-mutating, i.e. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"function rf(x::SVector, a, b)\n    return exp.(a*x) - b*x.^2\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Runtime setup (inside simulation): At the place where we want to solve the problem r(x)=0 No cache setup is required for static arrays. Hence, get the inputs a and b, define the true residual function with signature r=rf(x), define an initial guess x0, and call the newtonsolve","category":"page"},{"location":"","page":"Home","title":"Home","text":"a=rand(); b=rand();\nrf_true(x_) = rf(x_, a, b)\nx0 = zero(SVector{5})\nx, drdx, converged = newtonsolve(x0, rf_true);","category":"page"},{"location":"","page":"Home","title":"Home","text":"which as in the mutatable array case returns a the solution vector, the jacobian at the solution and a boolean whether  the solver converged or not. ","category":"page"},{"location":"#Benchmarks","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See benchmarks/benchmark.jl, on my laptop the results are","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> activate benchmarks/\njulia> include(\"benchmarks/benchmarks.jl\");\nBenchmark with dim=5\nrf (static):           33.099 ns (0 allocations: 0 bytes)\nrf (dynamic):          32.931 ns (0 allocations: 0 bytes)\nnewtonsolve static:    1.000 μs (0 allocations: 0 bytes)\nnewtonsolve dynamic:   2.400 μs (11 allocations: 1.50 KiB)\nnlsolve dynamic:       6.900 μs (58 allocations: 6.23 KiB)\n\nBenchmark with dim=10\nrf (static):           61.491 ns (0 allocations: 0 bytes)\nrf (dynamic):          66.187 ns (0 allocations: 0 bytes)\nnewtonsolve static:    4.200 μs (0 allocations: 0 bytes)\nnewtonsolve dynamic:   5.100 μs (7 allocations: 5.28 KiB)\nnlsolve dynamic:       11.400 μs (58 allocations: 12.25 KiB)\n\nBenchmark with dim=20\nrf (static):           119.333 ns (0 allocations: 0 bytes)\nrf (dynamic):          125.471 ns (0 allocations: 0 bytes)\nnewtonsolve static:    7.900 μs (16 allocations: 14.81 KiB)\nnewtonsolve dynamic:   14.600 μs (5 allocations: 4.38 KiB)\nnlsolve dynamic:       29.100 μs (62 allocations: 23.39 KiB)\n\nBenchmark with dim=40\nrf (static):           265.634 ns (0 allocations: 0 bytes)\nrf (dynamic):          251.370 ns (0 allocations: 0 bytes)\nnewtonsolve static:    38.600 μs (16 allocations: 53.69 KiB)\nnewtonsolve dynamic:   53.200 μs (5 allocations: 4.38 KiB)\nnlsolve dynamic:       83.400 μs (67 allocations: 55.67 KiB)","category":"page"},{"location":"","page":"Home","title":"Home","text":"showing that static arrays are faster than dynamic arrays with newtonsolve and that newtonsolve outperforms nlsolve in these specific cases. (nlsolve does not  support StaticArrays.)","category":"page"},{"location":"#Exported-API","page":"Home","title":"Exported API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Newton]\nPrivate = false","category":"page"},{"location":"#Newton.NewtonCache-Tuple{AbstractVector, Any}","page":"Home","title":"Newton.NewtonCache","text":"function NewtonCache(x::AbstractVector, rf!)\n\nCreate the cache used by the newtonsolve and linsolve!.  Only a copy of x will be used. \n\n\n\n\n\n","category":"method"},{"location":"#Newton.getx-Tuple{NewtonCache}","page":"Home","title":"Newton.getx","text":"getx(cache::NewtonCache)\n\nExtract out the unknown values. This can be used to avoid  allocations when solving defining the initial guess. \n\n\n\n\n\n","category":"method"},{"location":"#Newton.newtonsolve","page":"Home","title":"Newton.newtonsolve","text":"newtonsolve(x0::AbstractVector, drdx::AbstractMatrix, rf!, cache::ResidualCache; tol=1.e-6, maxiter=100)\n\nSolve the nonlinear equation system r(x)=0 using the newton-raphson method.  Returns x, drdx, true if converged and x, drdx, false otherwise.\n\nargs\n\nx0: Initial guess, not mutated (Unless aliased to getx(cache))\nrf!: Residual function. Signature rf!(r, x) and mutating the residual r\ncache: Optional cache that can be preallocated by calling ResidualCache(x0, rf!)\n\nkwargs\n\ntol=1.e-6: Tolerance on norm(r)\nmaxiter=100: Maximum number of iterations before no convergence\n\n\n\n\n\n","category":"function"},{"location":"#Newton.newtonsolve-Union{Tuple{dim}, Tuple{StaticArraysCore.SVector{dim}, Any}} where dim","page":"Home","title":"Newton.newtonsolve","text":"newtonsolve(x0::SVector, rf; tol=1.e-6, maxiter=100)\n\nSolve the nonlinear equation system r(x)=0 using the newton-raphson method. Returns type: (converged, x, drdx), SVector, SMatrix)` where \n\nconverged::Bool is true if converged and false otherwise\nx::SVector is the solution vector such that r(x)=0\ndrdx::SMatrix is the jacobian at x\n\nargs\n\nx0: Vector of with initial guess for unknowns.\nrf: Residual function. Signature r=rf(x::SVector{dim})::SVector{dim}\n\nkwargs\n\ntol=1.e-6: Tolerance on norm(r)\nmaxiter=100: Maximum number of iterations before no convergence\n\n\n\n\n\n","category":"method"},{"location":"#Internal-API","page":"Home","title":"Internal API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [Newton]\nPublic = false","category":"page"},{"location":"#Newton.linsolve!-Tuple{AbstractMatrix, AbstractVector, NewtonCache}","page":"Home","title":"Newton.linsolve!","text":"linsolve!(K::AbstractMatrix, b::AbstractVector, cache::NewtonCache)\n\nSolves the linear equation system Kx=b, mutating both K and b. b is mutated to the solution x\n\n\n\n\n\n","category":"method"}]
}
