var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Newton","category":"page"},{"location":"#Newton","page":"Home","title":"Newton","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of the small Newton.jl package is to provide a fast and efficient newton-raphson solver for nonlinear equation systems, suitable to be used inside a preformance critical loop. A key feature is that the jacobian at the solution is returned. It is mostly tested for small equations systems (<100 variables). When more fine-grained controlled over algorithms or more iteration information is desired, using NLsolve is recommended.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/KnutAM/Newton.jl\")\nusing Newton","category":"page"},{"location":"#Typical-usage","page":"Home","title":"Typical usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Solve r(x)=0 by calling","category":"page"},{"location":"","page":"Home","title":"Home","text":"x, drdx, converged = newtonsolve(x::Vector, rf!::Function, cache)\nx, drdx, converged = newtonsolve(x::Union{Real,SVector}, rf::Function)","category":"page"},{"location":"#Mutating-(standard)-Array","page":"Home","title":"Mutating (standard) Array","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Initial setup (before running simulation):  Define a mutating residual function rf! which depends on  parameters, e.g. a and b, only available during the simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"function rf!(r::Vector, x::Vector, a, b)\n    return map!(v->(exp(a*v)-b*v^2), r, x)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define the unknown array x and a residual function with the signature rf!(r,x) with inputs a and b of the same type as will be used later. Then preallocate cache","category":"page"},{"location":"","page":"Home","title":"Home","text":"x=zeros(5)\na = 1.0; b=1.0\nmock_rf!(r_, x_) = rf!(r_, x_, a, b)\ncache = NewtonCache(x,mock_rf!)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Runtime setup (inside simulation): At the place where we want to solve the problem r(x)=0","category":"page"},{"location":"","page":"Home","title":"Home","text":"a, b = rand(2); # However they are calculated during simulations\ntrue_rf!(r_, x_) = rf!(r_, x_, a, b)\nx0 = getx(cache)\n# Modify x0 as you wish to provide initial guess\nx, drdx, converged = newtonsolve(x0, true_rf!, cache)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is not necessary to get x0 from the cache, but this avoids allocating it. However, this implies that x0 will be aliased to the output, i.e. x0===x after solving. ","category":"page"},{"location":"#Non-mutating-StaticArray","page":"Home","title":"Non-mutating StaticArray","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Initial setup (before running simulation):  When using static arrays, the residual function should be non-mutating, i.e. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"function rf(x::SVector, a, b)\n    return exp.(a*x) - b*x.^2\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Runtime setup (inside simulation): At the place where we want to solve the problem r(x)=0 No cache setup is required for static arrays. Hence, get the inputs a and b, define the true residual function with signature r=rf(x), define an initial guess x0, and call the newtonsolve","category":"page"},{"location":"","page":"Home","title":"Home","text":"a=rand(); b=rand();\nrf_true(x_) = rf(x_, a, b)\nx0 = zero(SVector{5})\nx, drdx, converged = newtonsolve(x0, rf_true);","category":"page"},{"location":"","page":"Home","title":"Home","text":"which as in the mutatable array case returns a the solution vector, the jacobian at the solution and a boolean whether  the solver converged or not. ","category":"page"},{"location":"#Benchmarks","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See benchmarks/benchmark.jl, on my laptop the results are","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> activate benchmarks/\njulia> include(\"benchmarks/benchmarks.jl\");\nBenchmark with dim=5\nrf (static):           33.099 ns (0 allocations: 0 bytes)\nrf (dynamic):          32.931 ns (0 allocations: 0 bytes)\nnewtonsolve static:    1.000 μs (0 allocations: 0 bytes)\nnewtonsolve dynamic:   2.400 μs (11 allocations: 1.50 KiB)\nnlsolve dynamic:       6.900 μs (58 allocations: 6.23 KiB)\n\nBenchmark with dim=10\nrf (static):           61.491 ns (0 allocations: 0 bytes)\nrf (dynamic):          66.187 ns (0 allocations: 0 bytes)\nnewtonsolve static:    4.200 μs (0 allocations: 0 bytes)\nnewtonsolve dynamic:   5.100 μs (7 allocations: 5.28 KiB)\nnlsolve dynamic:       11.400 μs (58 allocations: 12.25 KiB)\n\nBenchmark with dim=20\nrf (static):           119.333 ns (0 allocations: 0 bytes)\nrf (dynamic):          125.471 ns (0 allocations: 0 bytes)\nnewtonsolve static:    7.900 μs (16 allocations: 14.81 KiB)\nnewtonsolve dynamic:   14.600 μs (5 allocations: 4.38 KiB)\nnlsolve dynamic:       29.100 μs (62 allocations: 23.39 KiB)\n\nBenchmark with dim=40\nrf (static):           265.634 ns (0 allocations: 0 bytes)\nrf (dynamic):          251.370 ns (0 allocations: 0 bytes)\nnewtonsolve static:    38.600 μs (16 allocations: 53.69 KiB)\nnewtonsolve dynamic:   53.200 μs (5 allocations: 4.38 KiB)\nnlsolve dynamic:       83.400 μs (67 allocations: 55.67 KiB)","category":"page"},{"location":"","page":"Home","title":"Home","text":"showing that static arrays are faster than dynamic arrays with newtonsolve and that newtonsolve outperforms nlsolve in these specific cases. (nlsolve does not  support StaticArrays.)","category":"page"},{"location":"#Exported-API","page":"Home","title":"Exported API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"newtonsolve\nNewtonCache\ngetx","category":"page"},{"location":"#Newton.newtonsolve","page":"Home","title":"Newton.newtonsolve","text":"newtonsolve(x0::AbstractVector, rf!, [cache::NewtonCache]; tol=1.e-6, maxiter=100)\n\nSolve the nonlinear equation (system) r(x)=0 using the newton-raphson method by calling the mutating residual function rf!(r, x), with signature rf!(r::T, x::T)::T where T<:AbstractVector x0 is the initial guess and the optional cache can be preallocated by calling NewtonCache(x0,rf!). Note that x0 is not modified, unless aliased to getx(cache).  tol is the tolerance for norm(r) and maxiter the maximum number of iterations. \n\nreturns x, drdx, converged::Bool\n\ndrdx is the derivative of r wrt. x at the returned x.\n\n\n\n\n\nnewtonsolve(x0::Union{SVector,Number}, rf; tol=1.e-6, maxiter=100)\n\nSolve the nonlinear equation (system) r(x)=0 using the newton-raphson method by calling the residual function r=rf(x), with signature rf(x::T)::T where T<:Union{SVector,Number}. x0 is the initial guess, tol the tolerance form norm(r), and maxiter the maximum number  of iterations. \n\nreturns: x, drdx, converged::Bool\n\ndrdx is the derivative of r wrt. x at the returned x.\n\n\n\n\n\n","category":"function"},{"location":"#Newton.NewtonCache","page":"Home","title":"Newton.NewtonCache","text":"function NewtonCache(x::AbstractVector, rf!)\n\nCreate the cache used by the newtonsolve and linsolve!.  Only a copy of x will be used. \n\n\n\n\n\n","category":"type"},{"location":"#Newton.getx","page":"Home","title":"Newton.getx","text":"getx(cache::NewtonCache)\n\nExtract out the unknown values. This can be used to avoid  allocations when solving defining the initial guess. \n\n\n\n\n\n","category":"function"},{"location":"#Internal-API","page":"Home","title":"Internal API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Newton.linsolve!","category":"page"},{"location":"#Newton.linsolve!","page":"Home","title":"Newton.linsolve!","text":"linsolve!(K::AbstractMatrix, b::AbstractVector, cache::NewtonCache)\n\nSolves the linear equation system Kx=b, mutating both K and b. b is mutated to the solution x\n\n\n\n\n\n","category":"function"}]
}
